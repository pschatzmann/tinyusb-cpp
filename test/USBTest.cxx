/**
 * Test cases for USBConfiuration.h - We expect that the descriptors returned by the framwork are identical to the
 * ones defined and used in the TinyUSB examples.
 * 
 * @copyright Copyright Phil Schatzmann (c) 2021
 * 
 */
#include "USBDescriptor.h"
#include "gtest/gtest.h"
#include "stdio.h"

#define CONFIG_TOTAL_LEN  (TUD_CONFIG_DESC_LEN + TUD_MIDI_DESC_LEN)
#define EPNUM_MIDI   0x01

tusb_desc_device_t const desc_device = {
    .bLength            = sizeof(tusb_desc_device_t),
    .bDescriptorType    = TUSB_DESC_DEVICE,
    .bcdUSB             = 0x0200,
    .bDeviceClass       = 0x00,
    .bDeviceSubClass    = 0x00,
    .bDeviceProtocol    = 0x00,
    .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,

    .idVendor           = 0xCafe,
    .idProduct          = 0x0001,
    .bcdDevice          = 0x0100,

    .iManufacturer      = 0x01,
    .iProduct           = 0x02,
    .iSerialNumber      = 0x03,

    .bNumConfigurations = 0x01
}; 

enum{
    ITF_NUM_MIDI = 0,
    ITF_NUM_MIDI_STREAMING,
    ITF_NUM_TOTAL
};


// define original configuration
const uint8_t desc_fs_configuration[] = {
    // Config number, interface count, string index, total length, attribute, power in mA
    TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 100),
    // Interface number, string index, EP Out & EP In address, EP size
    TUD_MIDI_DESCRIPTOR(ITF_NUM_MIDI, 0, EPNUM_MIDI, 0x80 | EPNUM_MIDI, 64)
};

// array of pointer to string descriptors
char const* string_desc_arr [] = {
  (const char[]) { 0x09, 0x04 }, // 0: is supported language is English (0x0409)
  "TinyUSB",                     // 1: Manufacturer
  "TinyUSB Device",              // 2: Product
  "123456",                      // 3: Serials, should use chip ID
};

static uint16_t _desc_str[32];

// Invoked when received GET STRING DESCRIPTOR request
// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)
{
  (void) langid;

  uint8_t chr_count;

  if ( index == 0)
  {
    memcpy(&_desc_str[1], string_desc_arr[0], 2);
    chr_count = 1;
  }else
  {
    // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.
    // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors

    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;

    const char* str = string_desc_arr[index];

    // Cap at max char
    chr_count = strlen(str);
    if ( chr_count > 31 ) chr_count = 31;

    // Convert ASCII string into UTF-16
    for(uint8_t i=0; i<chr_count; i++)
    {
      _desc_str[1+i] = str[i];
    }
  }

  // first byte is length (including header), second byte is string type
  _desc_str[0] = (TUSB_DESC_STRING << 8 ) | (2*chr_count + 2);

  return _desc_str;
}

// Make sure that the Device Descriptor generated by the framework are identical with the reference implementation
TEST(USBTests, Device) {
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");

//    EXPECT_TRUE(memcmp(desc_device, device.deviceDescriptor(),sizeof(tusb_desc_device_t))==0);	
    EXPECT_EQ(desc_device.bLength, device.descriptor()->bLength);
    EXPECT_EQ(desc_device.bDescriptorType, device.descriptor()->bDescriptorType);
    EXPECT_EQ(desc_device.bcdUSB, device.descriptor()->bcdUSB);
    EXPECT_EQ(desc_device.bDeviceClass, device.descriptor()->bDeviceClass);
    EXPECT_EQ(desc_device.bDeviceSubClass, device.descriptor()->bDeviceSubClass);
    EXPECT_EQ(desc_device.bDeviceProtocol, device.descriptor()->bDeviceProtocol);
    EXPECT_EQ(desc_device.bMaxPacketSize0, device.descriptor()->bMaxPacketSize0);
    EXPECT_EQ(desc_device.idVendor, device.descriptor()->idVendor);
    EXPECT_EQ(desc_device.idProduct, device.descriptor()->idProduct);
    EXPECT_EQ(desc_device.iSerialNumber, device.descriptor()->iSerialNumber);

    EXPECT_EQ(desc_device.bNumConfigurations, 1); 
    EXPECT_EQ(device.descriptor()->bNumConfigurations, 0); // 0 because no configurations have been defined yet

}

// Make sure that the Configuration Descriptor generated by the framework are identical with the reference implementation
TEST(USBTests, ConfigurationFromTinyUSBDescriptor) {
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");

    // set descriptor to API
    device.setConfigurationDescriptor(desc_fs_configuration, sizeof(desc_fs_configuration), false);   

    EXPECT_EQ(desc_device.bNumConfigurations, device.descriptor()->bNumConfigurations);
    EXPECT_EQ(device.usbConfigurationCount(),1);


    tusb_desc_configuration_t* data0 = (tusb_desc_configuration_t*)desc_fs_configuration;
    tusb_desc_configuration_t* data1 = (tusb_desc_configuration_t*)device.configurationDescriptor(0);

    EXPECT_EQ(data0->bLength,data1->bLength);
    EXPECT_EQ(data0->bDescriptorType,data1->bDescriptorType);
    EXPECT_EQ(data0->wTotalLength,data1->wTotalLength);
    EXPECT_EQ(data0->bNumInterfaces,data1->bNumInterfaces);
    EXPECT_EQ(data0->bConfigurationValue,data1->bConfigurationValue);
    EXPECT_EQ(data0->iConfiguration,data1->iConfiguration);
    EXPECT_EQ(data0->bmAttributes,data1->bmAttributes);
    EXPECT_EQ(data0->bMaxPower,data1->bMaxPower);
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(tusb_desc_device_t))==0);	

}

TEST(USBTests, ConfigurationFromWithParse) {
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");

    // set descriptor to API
    device.setConfigurationDescriptor(desc_fs_configuration, sizeof(desc_fs_configuration), true);   

    EXPECT_EQ(desc_device.bNumConfigurations, device.descriptor()->bNumConfigurations);
    EXPECT_EQ(device.usbConfigurationCount(),1);


    tusb_desc_configuration_t* data0 = (tusb_desc_configuration_t*)desc_fs_configuration;
    tusb_desc_configuration_t* data1 = (tusb_desc_configuration_t*)device.configurationDescriptor(0);

    EXPECT_EQ(data0->bLength,data1->bLength);
    EXPECT_EQ(data0->bDescriptorType,data1->bDescriptorType);
    EXPECT_EQ(data0->wTotalLength,data1->wTotalLength);
    EXPECT_EQ(data0->bNumInterfaces,data1->bNumInterfaces);
    EXPECT_EQ(data0->bConfigurationValue,data1->bConfigurationValue);
    EXPECT_EQ(data0->iConfiguration,data1->iConfiguration);
    EXPECT_EQ(data0->bmAttributes,data1->bmAttributes);
    EXPECT_EQ(data0->bMaxPower,data1->bMaxPower);
    // check over tusb_desc_configuration_t
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(tusb_desc_configuration_t))==0);	

    // check count
    EXPECT_EQ(device.usbConfigurationCount(),1);
    EXPECT_EQ(device.usbConfiguration(0)->usbInterfaceCount(),2);
    EXPECT_EQ(device.usbConfiguration(0)->usbInterface(0)->usbEndpointCount(),0);
    EXPECT_EQ(device.usbConfiguration(0)->usbInterface(1)->usbEndpointCount(),2);


}

TEST(USBTests, ConfigurationMIDI) {
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");
    
    uint8_t ca[] = {TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 100)};
    USBConfiguration* config = device.setConfigurationDescriptor(ca, sizeof(ca));  //9 
    uint8_t ba[] = {TUD_MIDI_DESCRIPTOR(ITF_NUM_MIDI, 0, EPNUM_MIDI, 0x80 | EPNUM_MIDI, 64)};
    config->addDescriptor(ba, sizeof(ba));


    EXPECT_EQ(desc_device.bNumConfigurations, device.descriptor()->bNumConfigurations);
    EXPECT_EQ(device.usbConfigurationCount(),1);

    // compare the generated configuration descriptor with the original
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(tusb_desc_configuration_t))==0);	

    // check total size
    tusb_desc_configuration_t* desc_config = (tusb_desc_configuration_t*)desc_fs_configuration;
    EXPECT_EQ(desc_config->wTotalLength, device.usbConfiguration(0)->totalSize());
    EXPECT_EQ(desc_config->wTotalLength, sizeof(desc_fs_configuration));

    // compare over total size
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(desc_fs_configuration))==0);	
    // for (int j=0;j<sizeof(desc_fs_configuration);j++){
    //    std::cout << j << ": '" << (int) desc_fs_configuration[j] << "' - '" << (int) device.configurationDescriptor(0)[j] << "' " << ( desc_fs_configuration[j] != device.configurationDescriptor(0)[j] ? "!!!" : "" )<< " \n";
    // }

}


TEST(USBTests, ConfigurationMIDIVarArg) {
    tusb_desc_configuration_t* desc_config = (tusb_desc_configuration_t*)desc_fs_configuration;
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");
    
    USBConfiguration* config = device.setConfigurationDescriptor(TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_TOTAL_LEN, TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 100));  //9 
    config->addDescriptor(TUD_MIDI_DESCRIPTOR(ITF_NUM_MIDI, 0, EPNUM_MIDI, 0x80 | EPNUM_MIDI, 64));

    EXPECT_EQ(desc_device.bNumConfigurations, device.descriptor()->bNumConfigurations);
    EXPECT_EQ(device.usbConfigurationCount(),1);
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(tusb_desc_configuration_t))==0);	
    EXPECT_EQ(desc_config->wTotalLength, device.usbConfiguration(0)->totalSize());
    EXPECT_EQ(desc_config->wTotalLength, sizeof(desc_fs_configuration));
    EXPECT_TRUE(memcmp(desc_fs_configuration, device.configurationDescriptor(0), sizeof(desc_fs_configuration))==0);	

}



// Make sure that the strings generated by the framework are identical with the reference implementation
TEST(USBTests, Strings) {
    USBDevice device = USBDevice::instance();
    device.clear();
    device.idVendor(0xCafe).idProduct(0x0001).bcdDevice(0x0100).manufacturer("TinyUSB").product("TinyUSB Device").serialNumber("123456");

    EXPECT_TRUE(USBStrings::equals(tud_descriptor_string_cb(0,0), device.string(0))==0) << "String 0 failed";
    EXPECT_TRUE(USBStrings::equals(tud_descriptor_string_cb(1,0), device.string(1))==0) << "String 1 failed";
    EXPECT_TRUE(USBStrings::equals(tud_descriptor_string_cb(2,0), device.string(2))==0) << "String 2 failed";
    EXPECT_TRUE(USBStrings::equals(tud_descriptor_string_cb(3,0), device.string(3))==0) << "String 3 failed";

}

int main() {
  ::testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}

